+++
title= "$12. [BOJ] 31095 등수"
date = "2025-11-09"
+++

{{< figure
  src="posts/test/images/31095.png"
  alt="terminal"
>}}

### Prob : [등수](https://www.acmicpc.net/problem/31095)


### Sol
N과 K에 따라 금성이의 대회 결과 경우를 알아보자. 아래에서 설명할 때 부등호는 학생들의 점수의 크기를 비교하는 용도로 쓰겠다. 금성이를 A로 표현하겠다.

1. N = 1일 때
   1. K = 1 : 1가지   
   1명 중에서 1등을 하는 경우는 당연히 1개밖에 없다.   
       - **A**   
2. N = 2일 때
   1. K = 1 : 2가지   
       - **A** = B
       - **A** > B
   2. K = 2 : 1
       - B > **A**
3. N = 3일 때
   1. K = 1 : 6가지   
       - **A** = B = C   
       - **A** = B > C   
       - **A** = C > B   
       - **A** > B = C   
       - **A** > B > C   
       - **A** > C > B   
   2. K = 2 : 4가지   
       - B > **A** = C
       - C > **A** = B
       - B > **A** > C
       - C > **A** > B
   3. K = 3 : 3가지   
       - B = C > **A**
       - B > C > **A**
       - C > B > **A**
4. N = 4일 때(예제입력1을 통해 가짓수만 적어두겠다.)
   1. K = 1 : 26가지   
   2. K = 2 : 18가지   
   3. K = 3 : 18가지   
   4. k = 4 : 13가지   

N과 K에 대해 (N, K)라고 했을 때, dp(N, K)를 N명 중 금성이가 K등을 할 수 있는 경우의 수를 저장하는 테이블로 설정해보자. 열을 N, 행을 K로 표현하겠다.

| ▼ K \ N ▶ | 1 | 2 | 3 | 4 | 5 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | 1 | 2 | 6 | 26 | ? |
| 2 | 0 | 1 | 4 | 18 | ? |
| 3 | 0 | 0 | 3 | 18 | ? |
| 4 | 0 | 0 | 0 | 13 | ? |
| 5 | 0 | 0 | 0 | 0 | ? |


N = 4일 때 상황을 전부 쓰기에는 슬슬 적지 않은 양이기에 관찰을 시작해보자. 먼저 첫번째와 마지막일 때를 보도록 하겠다.   
1. K = 1일 때   
	이는 N = 3인 모든 경우에서 맨 앞에 A를 붙여주기만 하면 된다. N = 3에 이미 A가 포함되어 있지 않냐라고 생각할 수 있는데, 이 3명을 모두 A가 아닌 다른 사람이라고 생각하면 되겠다. 우리는 단순히 경우의 수만 보기 때문에 상관없다. A를 붙일 때, A와 나머지 3명을 "A =" 또는 "A >"로 연결할 수 있다. 따라서 N = 3의 각 경우(K = 1~3)에 따라서 2배의 합이 된다. 그럼 다음과 같은 식으로 나타낼 수 있다.   
	$$
	dp(4,1) = \sum_{t=1}^{3} 2*dp(3,t)
	$$   
2. K = 4일 때   
	K = 1일 때와 반대로 N = 3인 모든 경우에서 맨 뒤에 A를 붙이면 된다. 다만, 붙일 때 =는 쓸 수 없고, 반드시 >로만 붙일 수 있다는 점에 주의하자. 왜 그럴까? N = 3에서는 가능한 가장 마지막 등수가 3등인데, K = 4는 반드시 4등을 해야한다. = 로 붙이면 A가 3등인 경우가 생기기 때문에 >로만 연결해야 한다. 따라서 N = 3의 각 경우(K = 1~3)의 모든 합이 된다.   
	$$
	dp(4,4) = \sum_{t=1}^{3} dp(3,t)
	$$
3. K = 3일 때
	K = 3인 경우는 다음과 같은 꼴이 가능하다.   
	{{< figure src="posts/test/images/1.png" alt="terminal" >}}
	나는 이것을 해결하기 위해 2개의 부분으로 나눠서 생각했다. 하나는 A가 3등을 하는 부분이고, 다른 하나는 A가 1등을 하는 부분이다. 이를 그림으로 표현하면 아래와 같다.  
	{{< figure src="posts/test/images/2.png" alt="terminal" >}}
	{{< figure src="posts/test/images/3.png" alt="terminal" >}}
	1. 첫번째 경우
	이는 정확하게 dp(3, 3)에 해당한다. 그런데 이 3명에 누가 포함될 수 있는지 생각해보자. A는 반드시 포함되어야 한다. 그럼 원래 4명중에서 A를 제외한 3명에 대해서 생각해볼 수 있겠다. 이 3명중에서 2명을 뽑으면 된다. 이것은 이제 $_3C_2$로 계산할 수 있다. 따라서 정리하면 첫번째 경우의 계산식은 아래와 같다.   
	$$
	dp(3, 3) * {_3}C_2
	$$
	2. 두번째 경우
	이는 dp(2,1)에 해당한다. 2명중에서 A를 제외한 1명에 대해 생각해보자. 아니, 정확하게는 깊은 생각을 할 필요까지 없다. 왜냐하면 첫번째 경우에서 골라진 사람들을 제외한 나머지 사람들이 자연스럽게 남을 것이기 때문이다. 따라서 두번째 경우의 계산식은 아래와 같다.   
	$$
	dp(2, 1)
	$$

	첫번째와 두번째 경우에 대해서 dp(4, 3)은 다음과 같이 수식을 세울 수 있다.   
	$$
	dp(4, 3) = dp(3, 3) * {_3}C{_2} * dp(2, 1)
	$$
4. K = 2일 때
	K = 3일 때와 같은 원리를 통해 아래 식을 세울 수 있다.   
	$$
	dp(4, 2) = dp(2, 2) * {_3}C{_1} * dp(3, 1)
	$$


자, 이제 우리는 N = 4에 대해 꽤나 자세히 생각해봤기에 적절한 점화식을 세울 수 있을 것이다.

> dp(n,k)에 대하여,
>1. K = N일 때   
	$$
	dp(n, n) = \sum_{t=1}^{n-1} dp(n-1,t)
	$$
>2. K = 1일 때   
	$$
	dp(n, 1) = \sum_{t=1}^{n-1} 2*dp(n-1,t) = 2{\sum_{t=1}^{n-1} dp(n-1,t)} = 2*dp(n,n)
	$$   
>3. $1 < K < N$일 때   
	$$
	dp(n, k) = dp(k, k) * {_{n-1}}C{_{k-1}} * dp(n-k+1, 1)
	$$   

이 문제에서 ${_{n}}C{_{k}}$ 의 계산과정 도중 시간이 걸릴 수 있으므로 파스칼의 삼각형을 이용해 ${_{n}}C{_{k}}$의 값을 저장한 테이블을 따로 만들어 바로 값을 참조할 수 있도록 한다. 나는 이를 combi(n,k)로 저장했다.


위 설명을 바탕으로 작성한 코드는 아래와 같다.


```c++
#define MAX_N 5000
#define MOD 1000000007
#include <iostream>
using namespace std;
long long int T, N, K,combi[MAX_N+1][MAX_N+1],dp[MAX_N+1][MAX_N+1];
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	long long int i, j, k;
	combi[1][0] = combi[1][1] = 1;
	for (i = 2; i <= MAX_N; i++) // make Combination
	{
		for (j = 0; j <= i; j++)
		{
			if (j == 0) combi[i][j] = 1;
			else combi[i][j] = (combi[i - 1][j - 1] + combi[i - 1][j]) % MOD;
		}
	}
	dp[1][0] = dp[1][1] = 1;
	for (i = 2; i <= MAX_N; i++)
	{
		dp[i][1] = (dp[i - 1][0] * 2) % MOD;
		dp[i][i] = dp[i - 1][0] % MOD;
		dp[i][0] = (dp[i][1] + dp[i][i]) % MOD;
		for (j = 2; j < i; j++)
		{
			dp[i][j] = (((dp[j][j] * combi[i - 1][j - 1])%MOD) * dp[i - j + 1][1]) % MOD;
			dp[i][0] = (dp[i][0] + dp[i][j]) % MOD;
		}
	}

	cin >> T;
	while (T--)
	{
		cin >> N >> K;
		cout << dp[N][K] << '\n';
	}
	return 0;
}
```
