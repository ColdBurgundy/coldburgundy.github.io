---
layout: post
title: $2. [BOJ] 2775 부녀회장이 될테야
subtitle: 
header-img: img/BOJ/2775.png
header-style: text
catalog: true
tags:
  - 2024
  - Bronze1
  - 수학
  - 구현
  - DP
---

### Prob : [부녀회장이 될테야](https://www.acmicpc.net/problem/2775)
평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.

이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.

아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.


### INPUT
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다

### OUTPUT
각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.

### Input range limitations
1 ≤ k, n ≤ 14



### Sol
어떤 생각을 하였는가 이 문제를 다읽고 나서. 물론 난이도는 어렵지 않은 문제이다. 중첩 반복문을 여러 개 사용하여 풀 수도 있다. 하지만 더 생각을 해보자.
이제 어떻게 생각하는가? 여전히 같은 아이디어를 떠올리는가? 그럼 테이블 하나를 이용하는 법에 대해 다시 생각해보자.

아. 혹시나 하는 말이지만 문제를 풀 때는 코드 에디터를 켜고 `#inlcude<stdio.h>`혹은 `#include <iostream>`이나 변수 선언, 입력을 미리 써놓는가? 이제는 그것을 뒤로 미루도록 하자. 코딩은 누구나(?)어렵지 않게 할 수 있다. 하지만 아이디어나 문제가 요구하는 사고력은 쉽지 않다. 따라서 반드시 이런 문제를 풀 때는 공책에 손으로 적어가면서 이것저것 적거나 그려보는 것을 추천한다. 그렇게 내가 생각한 것은 아래와 같았다.

![Alt text](/img/BOJ/2775/1.jpg)

map이라는 2차원 테이블을 그렸다. 이는 문제에 나오는 아파트를 그린 것이다. 여기서 $$map[i][j]$$는 $$i$$층 $$j$$호에 살고 있는 사람 수를 의미한다. 입력 조건으로 인해 $$1 ≤ i, j ≤ 14$$이다. 자, 그럼 다시 생각해보자. $$map[i][j]$$는 아파트의 임의의 위치이다. 따라서 명확하게 뭔가 상수인 값으로 정하기는 쉽지 않다.(정해진 값일지 아닐지 모르는 상태이기 때문에)

그럼 $$map[i][j]$$의 값은 어떻게 구할까? 문제에 의해 다음과 같이 수식으로 나타낼 수 있을 것이다.

\(
map[i][j] = \sum_{k=1}^{j-1} { map[i-1][k] }
\)


이제 당신은 그냥 반복문 쓰면 될 일 아니냐고 따질 것이다. 좋은 지적이다. 하지만 i와 j가 매우 큰 값이라면 컴퓨터는 계산을 하다 정신이 나가버릴 것이다. 혹은, 매우 오랜시간이 걸릴 것이다. 그러면 또 다시 따질 것 같다. 어차피 k와 n의 최대값이 14면 상관없는거 아닌가? 맞다. 전혀 상관없다. 그래서 이 문제만큼은 그렇게 풀어도 될지도 모른다. 그럼 왜 이런 성가신 짓거리를 하고 있는걸까? 생각하는 방법을 넓히기 위해서다. 그럼 설명을 이어나가겠다. 혹시 위 그림에서 $$map[i][j]$$의 왼쪽 칸이 무엇인지 아는가? 놀랍게도 $$map[i][j-1]$$이다. 이렇게 당연한 것을 왜 물었을까? 이것을 이용하자는 거다. 어떻게 이용하는 걸까? 라는 물음에 대답하기 위해서는 $$map[i][j-1]$$의 정석적인 수식을 보자.

$$map[i][j-1] = \sum_{k=1}^{j-2} {map[i-1][k]}$$

어어 화내지 마라. 수식으로만 적혀있으면 눈에 잘 보이지않는 법이다. 두 식을 풀어서 써보겠다.

$$map[i][j]=map[i-1][1]+map[i-1][2]+\cdots+map[i-1][j-1]+map[i-1][j]$$   
$$map[i][j-1]=map[i-1][1]+map[i-1][2]+\cdots+map[i-1][j-2]+map[i-1][j-1]$$

혹시 보이는가? $$map[i][j-1]$$은 사실 $$map[i][j]$$의 포함된 계산이다. 그럼 나는 다음과 같은 식을 쓸 수 있다.

$$map[i][j]=map[i][j-1]+map[i-1][j]$$

어떤가? 이렇게 한 곳의 위치에 대해 수식으로 깔끔하게 표현했다. 이로써 우리는 반복문 하나를 줄인 셈이 되었고, 컴퓨터에게 더 적은 일을 시킬 수 있다. 이는 더 효율적인 방법임을 의미한다. 이제 저 식을 "점화식"이라고 부르자. 그리고  문제를 다시 읽은 후 초기값을 설정해보자.

$$map[i][j]=j\qquad when\quad i=0$$

지금까지 여러분이 본 것은 다이나믹 프로그래밍(Dynamic Programming)의 풀이법이다. 아마 정리노트에 관련 설명을 적어놓을 예정이다. 어쨌든 위 설명을 코드로 옮기면 아래와 같다.



### Code
```c
#define _CRT_SECURE_NO_WARNINGS
#define MAX_NK 14
#include <stdio.h>
int main()
{
	int T, k, n, map[MAX_NK + 1][MAX_NK + 1] = { 0, }, i, j;
	for (i = 0; i <= MAX_NK; i++)
	{
		for (j = 1; j <= MAX_NK; j++)
		{
			if (!i) map[i][j] = j;
			else map[i][j] = map[i][j - 1] + map[i - 1][j];
		}
	}
	scanf("%d", &T);
	for (i = 0; i < T; i++)
	{
		scanf("%d %d", &k, &n);
		printf("%d\n", map[k][n]);
	}
	return 0;
}
```
