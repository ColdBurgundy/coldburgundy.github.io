---
layout: post
title: $5. [BOJ] 11047 동전 0
subtitle: 
header-img: /img/BOJ/11047.png
header-style: text
catalog: true
katex: True
tags:
  - 2024
  - Silver4
  - 그리디
---

![Alt text](/img/BOJ/11047.png)


### Prob : [동전 0](https://www.acmicpc.net/problem/11047)
준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

### INPUT
첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

### OUTPUT
첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.


### Sol

동전문제에는 굉장히 다양한 문제가 존재한다. 같은 동전유형의 문제더라도 푸는 방식은 완전히 다르며, 그에 따라서 난이도 또한 달라진다. 이 문제를 처음보는 사람들은 대부분 다음과 같은 생각을 한다.

> "큰 값어치로부터 차례대로 나누면서, 몫의 누적 합을 계산하면 정답을 구할 수 있겠구나."

매우 훌륭한 아이디어다. 적어도 이 문제에서는 말이다. 그럼 왜 적어도 이 문제에서는 저렇게 풀어도 괜찮은걸까? 문제 속에 다음 문장이 포함되어 있다.

> A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수

굉장히 중요한 단서다. $$A_i$$는 $$A_{i-1}$$의 배수라는 말은 당신이 냈던 아이디어를 사용해도 좋은 밑바탕이 된다. 왜냐면 굉장히 복잡하게 어정쩡한 계산이 불필요하기 때문이다. 예를 들어 보겠다.   

만약 동전에는 1원, 7원, 9원짜리만 있고, 만들고자 하는 값을 24원이라고 하자. 당신의 원래 아이디어대로 계산했다면 $$24 = (2*9)+(6*1)$$로 계산하여 최소 필요한 동전의 개수를 8개라고 했을 것이다. 하지만 $$24 = (1*9)(2*7)+(1*1)$$로 4개의 동전만으로 충분하다. 내가 방금 언급한 문제는 다른 동전문제에 존재한다. 하지만 이것은 이 문제를 푸는데에는 중요하지 않다.   

다시 본래 문제로 돌아가보자. 어쨌든, 이 문제를 풀고있는 우리는 몫과 나머지에 대해서만 고려하면 되겠다.  K를 가장 높은 동전의 가치로 나눈 몫을 저장하면서, 그 이후에 나머지를 K에 저장한다. 그렇게 바뀐 K를 2번째로 높은 동전의 가치로 나누면서 반복하면 된다. 누적된 몫의 합을 계속 저장하면서 마지막에 출력하면 이 문제를 해결할 수 있다.   

다음은 위 과정을 코드로 작성한 모습이다.


### Code
```c
#define _CRT_SECURE_NO_WARNINGS
#define MAX_N 10
#include <stdio.h>
int main()
{
	int N, K, i, num = 0, val[MAX_N];
	scanf("%d %d", &N, &K);
	for (i = 0; i < N; i++)
		scanf("%d", &val[N - 1 - i]);
	for (i = 0; i < N; i++)
	{
		num += (K / val[i]);
		K %= val[i];
	}
	printf("%d", num);
	return 0;
}
```