---
layout: post
title: $18. [BOJ] 1987 알파벳
subtitle: 
header-img: /img/BOJ/1987.png
header-style: text
catalog: true
katex: True
tags:
  - 2024
  - Gold4
  - 그래프이론
  - 그래프탐색
  - 깊이우선탐색
  - 백트레킹
---

![Alt text](/img/BOJ/1987.png)


### Prob : [알파벳](https://www.acmicpc.net/problem/1987)

세로 
$R$칸, 가로 $C$칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 ($1$행 $1$열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.


### INPUT
첫째 줄에 $R$과 $C$가 빈칸을 사이에 두고 주어진다. ($1 ≤ R,C ≤ 20$) 둘째 줄부터 $R$개의 줄에 걸쳐서 보드에 적혀 있는 $C$개의 대문자 알파벳들이 빈칸 없이 주어진다.


### OUTPUT
첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.


### Sol

아래 코드는 보드에서 말이 이동할 수 있는 최대 칸 수를 찾는 문제를 해결한다. 코드는 깊이 우선 탐색(DFS)를 사용하여, 말이 이동할 때마다 새로운 칸에 적힌 알파벳이 이전에 방문한 칸의 알파벳과 중복되지 않도록 한다.

먼저, R과 C를 입력받아 보드의 크기를 설정한다. 그 다음에는 보드에 적힌 알파벳을 입력받아 2차원 벡터 v에 저장한다. check 벡터는 각 알파벳이 이미 사용되었는지를 추적한다. 알파벳 'A'부터 'Z'까지 총 26개를 대응하기 위해 크기가 26인 벡터를 사용한다.

dfs 함수는 현재 위치에서 시작하여 말이 이동할 수 있는 모든 경로를 탐색한다. 이 함수는 현재 위치의 알파벳을 체크하고, lar 변수를 사용하여 지금까지 방문한 칸 수의 최댓값을 갱신한다. 각 단계에서, 말은 상하좌우 네 방향 중 하나로 이동할 수 있다. 이 때, 다음 이동할 칸이 보드 내에 있고, 아직 방문하지 않은 알파벳이어야 한다. 만약 이동할 수 있는 칸이 있다면, dfs 함수를 재귀적으로 호출하여 그 방향으로 탐색을 계속한다. 탐색이 끝나면, 방문했던 알파벳을 다시 사용할 수 있도록 check 벡터를 갱신한다.

이 코드의 타당성은 다음과 같은 점에서 드러난다:

1. DFS (깊이 우선 탐색): 모든 가능한 경로를 탐색하는데 적합한 방법. 현재 위치에서 이동할 수 있는 각각의 다음 위치로 재귀적으로 탐색을 확장한다.
2. 알파벳 체크: 말이 동일한 알파벳을 두 번 지나지 않도록 한다. 이는 문제의 핵심 요구사항을 충족시키는 데 중요하다.
3. 모든 방향 탐색: 말은 상하좌우 네 방향으로 이동할 수 있다. 각 방향에 대해 다음 이동 위치를 결정하고, 재귀적으로 탐색을 계속한다.
4. 경로 갱신: 탐색이 끝날 때마다 check 벡터를 갱신하여 다른 경로에서 해당 알파벳을 다시 사용할 수 있도록 한다. 이는 각각의 경로가 독립적으로 탐색되도록 하여, 최대 칸 수를 정확하게 계산한다.
5. 최대 칸 수 계산: lar 변수는 지금까지 탐색한 경로 중 가장 많은 칸을 지난 경우의 칸 수를 저장한다.

마지막으로, dfs 함수를 (0, 0) 위치에서 호출하여 탐색을 시작한다. 탐색이 끝나면, lar에 저장된 최대 칸 수를 출력한다. 이 코드는 DFS를 사용하여 격자판의 모든 가능한 경로를 탐색하고, 말이 이동할 수 있는 최대 칸 수를 효과적으로 찾아낸다. 격자판 내에서 말이 지날 수 있는 모든 칸을 고려하며, 동시에 같은 알파벳 칸을 두 번 지나지 않는 문제의 조건을 만족시킨다.



```c++
#define MAX_RC 20
#include <iostream>
#include <vector>
using namespace std;
int R, C, lar;
int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };
vector<vector<char>> v(MAX_RC, vector<char>(MAX_RC));
vector<int> check(26);
void dfs(int y, int x, int len)
{
	check[v[y][x] - 'A'] = 1;
	lar = max(lar, len);
	for (int i = 0; i < 4; i++)
	{
		int ny = dy[i] + y;
		int nx = dx[i] + x;
		if (0 <= nx && nx < C && 0 <= ny && ny < R && check[v[ny][nx] - 'A'] == 0)
		{
			dfs(ny, nx, len + 1);
			check[v[ny][nx] - 'A'] = 0;
		}
	}
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cin >> R >> C;
	for (int i = 0; i < R; i++)
	{
		for (int j = 0; j < C; j++)
			cin >> v[i][j];
		cin.ignore();
	}
	dfs(0, 0, 1);
	cout << lar;
}
```