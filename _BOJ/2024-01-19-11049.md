---
layout: post
title: $19. [BOJ] 11049 행렬 곱셈 순서
subtitle: 
header-img: /img/BOJ/11049.png
header-style: text
catalog: true
katex: True
tags:
  - 2024
  - Gold3
  - DP
---

![Alt text](/img/BOJ/11049.png)


### Prob : [행렬 곱셈 순서](https://www.acmicpc.net/problem/11049)
크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.

예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.

* AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.   
* BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.

같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.

행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.



### INPUT
첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.

둘째 줄부터 N개 줄에는 행렬의 크기 r과 c가 주어진다. (1 ≤ r, c ≤ 500)

항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.


### OUTPUT
첫째 줄에 입력으로 주어진 행렬을 곱하는데 필요한 곱셈 연산의 최솟값을 출력한다. 정답은 231-1 보다 작거나 같은 자연수이다. 또한, 최악의 순서로 연산해도 연산 횟수가 $$2^{31}-1$$보다 작거나 같다.


### Sol

이 문제는 행렬들을 곱하는 순서에 따라 필요한 연산 횟수가 달라지는 것이 핵심이다. 여기서 동적 프로그래밍 알고리즘을 적용하는 것이 효율적이다.

1. 2차원 DP 테이블 구성: dp[i][j]는 행렬 i부터 j까지 곱했을 때 필요한 최소 곱셈 연산 횟수를 나타낸다. 초기에 INT_MAX로 설정해둔다. 이 테이블은 각각의 행렬 조합에 대한 최소 연산 횟수를 저장하는 데 사용된다.

2. 행렬 크기 저장: 각 행렬의 크기는 data 벡터에 저장한다. 이 크기 정보는 행렬을 곱할 때 필요한 연산 횟수를 계산하는 데 쓰인다.

3. 초기화: dp[i][i + 1] = 0으로 초기화하는 것은 단일 행렬에 대해선 곱셈 연산이 필요 없음을 의미한다. 이건 DP 테이블의 기저 조건을 설정하는 것이다.

4. 중첩 루프로 탐색:
	* 바깥쪽 루프는 감소하는 순서로 진행한다. 이는 작은 문제부터 해결하여 그 결과를 큰 문제 해결에 활용하기 위함이다.
	* 안쪽 루프는 각 부분 문제에 대해 가능한 모든 분할을 탐색한다.
	* 가장 안쪽 루프는 행렬의 분할 지점을 정한다. 이 지점은 행렬 곱셈의 순서를 결정한다.
  
5. 최소 연산 횟수 계산: 분할에 대해, dp[i][k] + dp[k][j] + (data[i] * data[j] * data[k])를 통해 최소 곱셈 연산 횟수를 찾는다.
   
6. 결과 도출: dp[0][N - 1]이 최종 최소 연산 횟수다.

이 알고리즘은 행렬 곱셈 순서 문제의 특성을 잘 활용한다. 동적 프로그래밍은 각 부분 문제를 효율적으로 해결하고, 전체 문제의 최적해를 찾아낸다. 이 방식은 문제의 요구사항을 정확히 반영하고 있다.



```c++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
int N;
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cin >> N;
	vector<int> data(N + 1);
	vector<vector<int>> dp(N + 1, vector<int>(N + 1, INT_MAX));
	for (int i = 0; i < N; i++)
	{
		int r, c;
		cin >> r >> c;
		dp[i][i + 1] = 0;
		if (i == 0)
		{
			data[0] = r;
			data[1] = c;
			continue;
		}
		data[i + 1] = c;
	}
	N++;
	for (int i = N - 3; i >= 0; i--)
	{
		for (int j = i + 2; j < N; j++)
		{
			for (int k = i + 1; k <= j - 1; k++)
			{
				int tmp = dp[i][k] + dp[k][j] + (data[i] * data[j] * data[k]);
				dp[i][j] = min(dp[i][j], tmp);
			}
		}
	}
	cout << dp[0][N - 1];
	return 0;
}
```